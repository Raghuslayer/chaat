<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ephemeral Chat</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.2/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.2/firebase-auth-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.2/firebase-firestore-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.2/firebase-database-compat.min.js"></script> <!-- Added Realtime Database -->
    <style>
        /* CSS Variables for consistent theming and easy adjustments */
        :root {
            /* New Color Palette: Deep Blue/Purple with Vibrant Teal/Cyan Accents for a sleek, modern look */
            --primary-color: #6A1B9A; /* Sophisticated Purple */
            --primary-hover: #4A148C; /* Darker Purple for hover */
            --secondary-color: #00BCD4; /* Vibrant Teal/Cyan for accents */
            --secondary-hover: #0097A7; /* Darker Teal for hover */
            --dark-bg: #1A202C; /* Deep charcoal/almost black for main background */
            --light-bg: #2D3748; /* Slightly lighter dark gray for cards/sections */
            --text-light: #E2E8F0; /* Soft white for general text on dark backgrounds */
            --text-dark: #FFFFFF; /* Pure white for important text/headers */
            --gray-text: #A0AEC0; /* Lighter gray for secondary text */
            --error-color: #EF4444; /* Red for errors */
            --success-color: #10B981; /* Green for success */
            --info-color: #00BCD4; /* Teal for info toasts */

            /* Enhanced Shadows and Borders */
            --border-radius-sm: 0.5rem; /* Smaller radius for inputs */
            --border-radius-md: 0.75rem; /* Medium radius for cards */
            --border-radius-lg: 1rem; /* Larger radius for messages/main elements */
            --shadow-sm: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.2);
            --shadow-md: 0 0.5rem 1rem rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 1rem 2rem rgba(0, 0, 0, 0.4);
            
            /* Responsive Sizing */
            --base-font-size: clamp(0.875rem, 2.5vw, 1rem); /* Responsive base font size */
            --sidebar-width: clamp(18rem, 25vw, 22rem); /* Slightly wider sidebar */
            --container-max-width: 90rem;
        }

        /* Basic Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Prefer Inter if available, fallback to Segoe UI */
        }

        /* HTML and Body base styles for fluid typography and full height layout */
        html {
            font-size: var(--base-font-size);
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg) 0%, #111827 100%); /* Subtle dark gradient background */
            background-size: 200% 200%; /* For animation */
            animation: gradient-animation 15s ease infinite; /* Background animation */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: var(--base-font-size);
            overflow: hidden; /* Prevent body scroll, handled by individual sections */
            color: var(--text-light); /* Default text color */
        }

        /* General container styling for content areas */
        .container {
            width: 100%;
            max-width: var(--container-max-width);
            margin: 0 auto;
            padding: clamp(0.5rem, 2vw, 1rem);
            flex: 1;
        }

        .hidden {
            display: none !important;
        }

        /* --- Auth Container Styles --- */
        .auth-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: rgba(0, 0, 0, 0.4); /* Semi-transparent overlay for auth screens */
            padding: clamp(1rem, 5vw, 2rem);
            width: 100%;
        }

        .auth-box {
            background-color: var(--light-bg); /* Lighter dark gray */
            border-radius: var(--border-radius-lg); /* More rounded corners */
            box-shadow: var(--shadow-lg); /* Larger, softer shadow */
            width: clamp(18rem, 90vw, 28rem); /* Responsive width */
            padding: clamp(1.5rem, 5vw, 2.5rem); /* More padding */
            animation: slideUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; /* Smoother animation */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
        }

        .auth-logo {
            text-align: center;
            margin-bottom: clamp(1rem, 3vw, 2rem);
        }

        .auth-logo h1 {
            color: var(--secondary-color); /* Vibrant teal for logo */
            font-size: clamp(2rem, 5vw, 2.8rem);
            margin-bottom: 0.5rem;
            font-weight: 800; /* Extra bold */
            text-shadow: 0 0 10px rgba(0, 188, 212, 0.5); /* Subtle glow */
        }

        .auth-logo p {
            color: var(--gray-text);
            font-size: clamp(0.85rem, 2vw, 1rem);
            line-height: 1.4;
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: clamp(0.75rem, 2vw, 1.2rem);
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .form-group label {
            font-size: clamp(0.9rem, 2vw, 1.05rem);
            font-weight: 600;
            color: var(--text-light);
        }

        .form-group input {
            padding: clamp(0.7rem, 2vw, 0.9rem);
            border: 1px solid rgba(255, 255, 255, 0.2); /* Lighter border */
            border-radius: var(--border-radius-sm);
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            background-color: rgba(0, 0, 0, 0.3); /* Slightly transparent input */
            color: var(--text-dark);
            transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
            width: 100%;
        }

        .form-group input::placeholder {
            color: var(--gray-text);
            opacity: 0.7;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--secondary-color); /* Teal focus border */
            box-shadow: 0 0 0 0.25rem rgba(0, 188, 212, 0.25); /* Teal focus shadow */
            background-color: rgba(0, 0, 0, 0.5); /* Darker on focus */
        }

        .auth-button {
            background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%); /* Gradient button */
            color: var(--text-dark);
            border: none;
            border-radius: var(--border-radius-sm);
            padding: clamp(0.75rem, 2vw, 1rem) 1.5rem;
            font-size: clamp(0.95rem, 2.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.7rem; /* Increased gap */
            box-shadow: var(--shadow-sm);
            letter-spacing: 0.05em; /* Slight letter spacing */
        }

        .auth-button:hover {
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%); /* Reverse gradient on hover */
            transform: translateY(-2px) scale(1.01);
            box-shadow: var(--shadow-md);
        }

        .auth-button:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .auth-button:disabled {
            background: #4A5568; /* Desaturated background for disabled */
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
            box-shadow: none;
        }

        .auth-alt {
            margin-top: clamp(1rem, 3vw, 1.8rem);
            text-align: center;
        }

        .auth-alt p {
            color: var(--gray-text);
            font-size: clamp(0.8rem, 2vw, 0.95rem);
        }

        .auth-alt a {
            color: var(--secondary-color); /* Teal for links */
            text-decoration: none;
            font-weight: 600;
            cursor: pointer;
            transition: color 0.2s ease, text-shadow 0.2s ease;
        }

        .auth-alt a:hover {
            text-decoration: underline;
            color: var(--text-dark);
            text-shadow: 0 0 5px var(--secondary-color);
        }

        .error-message {
            color: var(--error-color);
            font-size: clamp(0.8rem, 2vw, 0.95rem);
            margin-top: 0.6rem;
            text-align: center;
            font-weight: 500;
        }

        .success-message {
            color: var(--success-color);
            font-size: clamp(0.8rem, 2vw, 0.95rem);
            margin-top: 0.6rem;
            text-align: center;
            font-weight: 500;
        }

        .username-setup {
            text-align: center;
            animation: fadeInScale 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .username-setup h2 {
            margin-bottom: clamp(0.75rem, 2vw, 1.2rem);
            color: var(--secondary-color);
            font-size: clamp(1.6rem, 4vw, 2rem);
            font-weight: 700;
        }

        .username-setup p {
            color: var(--gray-text);
            margin-bottom: clamp(1rem, 3vw, 1.8rem);
            font-size: clamp(0.9rem, 2.5vw, 1.05rem);
        }

        /* --- App Container Styles --- */
        .app-container {
            display: grid;
            grid-template-columns: minmax(0, var(--sidebar-width)) 1fr;
            height: 100vh;
            overflow: hidden;
            width: 100%;
            background-color: transparent; /* Main background handled by body */
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg); /* Main app container shadow */
        }

        .sidebar {
            background-color: var(--light-bg); /* Lighter dark gray */
            border-right: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
            display: flex;
            flex-direction: column;
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smoother transition */
            width: 100%;
            position: relative; /* For z-index context */
            z-index: 20; /* Ensure sidebar is above main chat on mobile */
        }

        .sidebar-header {
            padding: clamp(0.8rem, 2vw, 1.2rem);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.1); /* Slightly darker header */
            box-shadow: var(--shadow-sm);
        }

        .sidebar-header h2 {
            color: var(--text-dark);
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            font-weight: 700;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
        }

        .user-menu {
            position: relative;
        }

        .user-button {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--gray-text);
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            padding: 0.3rem;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        .user-button:hover {
            color: var(--secondary-color);
            transform: rotate(90deg); /* Rotate icon on hover */
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background-color: var(--light-bg);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-md);
            z-index: 30; /* Above sidebar content */
            min-width: clamp(9rem, 20vw, 12rem);
            margin-top: 0.7rem;
            animation: fadeIn 0.2s ease-out;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden; /* For rounded corners */
        }

        .dropdown-menu ul {
            list-style: none;
        }

        .dropdown-menu li {
            padding: clamp(0.6rem, 2vw, 0.9rem) 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            font-size: clamp(0.9rem, 2.5vw, 1.05rem);
            display: flex;
            align-items: center;
            gap: 0.6rem;
            color: var(--text-light);
        }

        .dropdown-menu li:hover {
            background-color: var(--primary-color); /* Purple highlight on hover */
            color: var(--text-dark);
            transform: translateX(5px); /* Slide effect on hover */
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(0, 0, 0, 0.1);
        }

        .tab {
            flex: 1;
            text-align: center;
            padding: clamp(0.7rem, 2vw, 1.1rem);
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--gray-text);
            font-weight: 600;
            font-size: clamp(0.9rem, 2.5vw, 1.05rem);
            letter-spacing: 0.02em;
        }

        .tab.active {
            color: var(--secondary-color);
            border-bottom: 3px solid var(--secondary-color); /* Thicker active border */
            background-color: var(--light-bg);
            text-shadow: 0 0 5px rgba(0, 188, 212, 0.3);
        }

        .tab:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.05); /* Subtle hover for inactive tabs */
            color: var(--text-dark);
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: clamp(0.5rem, 1.5vw, 0.8rem);
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: var(--secondary-color) rgba(255, 255, 255, 0.1); /* Firefox */
        }
        /* Webkit scrollbar styles */
        .tab-content::-webkit-scrollbar {
            width: 8px;
        }
        .tab-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        .tab-content::-webkit-scrollbar-thumb {
            background-color: var(--secondary-color);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .search-bar {
            margin: clamp(0.5rem, 1.5vw, 0.8rem);
            position: relative;
        }

        .search-bar input {
            width: 100%;
            padding: clamp(0.6rem, 2vw, 0.8rem) clamp(0.7rem, 2vw, 1rem) clamp(0.6rem, 2vw, 0.8rem) clamp(2.2rem, 5vw, 2.8rem);
            border-radius: clamp(1.2rem, 3vw, 1.5rem);
            border: 1px solid rgba(255, 255, 255, 0.15);
            font-size: clamp(0.9rem, 2vw, 1rem);
            background-color: rgba(0, 0, 0, 0.2);
            color: var(--text-light);
            transition: all 0.3s ease;
        }
        .search-bar input::placeholder {
            color: var(--gray-text);
            opacity: 0.7;
        }

        .search-bar input:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 0.2rem rgba(0, 188, 212, 0.2);
            background-color: rgba(0, 0, 0, 0.4);
        }

        .search-bar i {
            position: absolute;
            left: clamp(0.7rem, 2vw, 1rem);
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray-text);
            font-size: clamp(0.9rem, 2vw, 1.1rem);
        }

        .friend-list, .request-list {
            display: flex;
            flex-direction: column;
            gap: clamp(0.3rem, 1vw, 0.6rem);
            padding-bottom: 0.5rem; /* Ensure space above add friend form */
        }

        .friend-item, .request-item {
            display: flex;
            align-items: center;
            padding: clamp(0.6rem, 2vw, 0.9rem);
            border-radius: var(--border-radius-md);
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            animation: fadeIn 0.4s ease forwards;
            position: relative;
            background-color: rgba(255, 255, 255, 0.05); /* Subtle background */
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .friend-item:hover {
            background-color: rgba(0, 188, 212, 0.1); /* Teal tinted hover */
            transform: translateY(-2px) scale(1.01);
            box-shadow: var(--shadow-sm);
        }

        .friend-item.active {
            background: linear-gradient(90deg, rgba(106, 27, 154, 0.2) 0%, rgba(0, 188, 212, 0.2) 100%); /* Active chat gradient */
            border-left: 3px solid var(--secondary-color);
            padding-left: calc(clamp(0.6rem, 2vw, 0.9rem) - 3px); /* Adjust padding for border */
        }

        .friend-avatar {
            width: clamp(2.5rem, 10vw, 3rem);
            height: clamp(2.5rem, 10vw, 3rem);
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color)); /* Gradient avatar */
            color: var(--text-dark);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: clamp(0.6rem, 2vw, 1rem);
            flex-shrink: 0;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            box-shadow: 0 0 8px rgba(0, 188, 212, 0.3); /* Subtle glow */
        }

        .request-item .friend-avatar {
            background: linear-gradient(45deg, #718096, #4A5568); /* Grey gradient for requests */
        }

        .friend-info {
            flex: 1;
            display: flex; /* Make friend-info a flex container */
            align-items: center; /* Align items vertically */
            justify-content: space-between; /* Space out name/status and indicator */
        }
        .friend-info .name-and-status {
            display: flex;
            flex-direction: column;
            flex: 1; /* Allow it to take available space */
        }

        .friend-name {
            font-weight: 600;
            color: var(--text-dark);
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
        }

        .friend-status {
            font-size: clamp(0.75rem, 2vw, 0.85rem);
            color: var(--gray-text);
            margin-top: 0.2rem;
        }

        /* Online Status Indicator */
        .online-indicator {
            width: 0.6rem;
            height: 0.6rem;
            border-radius: 50%;
            margin-left: auto; /* Push to right */
            flex-shrink: 0;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .online-indicator.online {
            background-color: var(--success-color); /* Green */
            box-shadow: 0 0 5px var(--success-color);
        }
        .online-indicator.offline {
            background-color: var(--gray-text); /* Gray */
        }

        .unread-dot {
            position: absolute;
            top: 50%;
            right: 0.75rem;
            transform: translateY(-50%);
            width: 0.85rem; /* Slightly larger dot */
            height: 0.85rem;
            background-color: var(--error-color); /* Red for unread */
            border-radius: 50%;
            animation: pulse 1.8s infinite cubic-bezier(0.4, 0, 0.6, 1); /* Smoother pulse */
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); /* Red pulse shadow */
            border: 1px solid rgba(255, 255, 255, 0.3); /* White border */
        }

        @keyframes pulse {
            0% {
                transform: translateY(-50%) scale(0.9);
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }
            70% {
                transform: translateY(-50%) scale(1.1);
                box-shadow: 0 0 0 0.8rem rgba(239, 68, 68, 0);
            }
            100% {
                transform: translateY(-50%) scale(0.9);
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        .request-item {
            background-color: rgba(255, 255, 255, 0.07);
            border: 1px solid rgba(255, 255, 255, 0.1);
            flex-direction: column;
            align-items: flex-start;
            padding: clamp(0.8rem, 3vw, 1.2rem);
        }

        .request-info {
            display: flex;
            align-items: center;
            width: 100%;
            margin-bottom: clamp(0.6rem, 2vw, 1rem);
        }

        .request-info .friend-info {
            margin-left: clamp(0.6rem, 2vw, 1rem);
            flex: 1;
        }

        .request-buttons {
            display: flex;
            gap: clamp(0.3rem, 1vw, 0.6rem);
            width: 100%;
        }

        .request-button {
            flex: 1;
            padding: clamp(0.4rem, 1.5vw, 0.7rem);
            border-radius: var(--border-radius-sm);
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: clamp(0.85rem, 2vw, 1rem);
            box-shadow: var(--shadow-sm);
            letter-spacing: 0.02em;
            display: flex; /* Make buttons flex to center content */
            align-items: center;
            justify-content: center;
            gap: 0.4rem; /* Gap between icon and text */
        }

        .accept-button {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: var(--text-dark);
        }

        .accept-button:hover {
            background: linear-gradient(45deg, var(--secondary-color), var(--primary-color));
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--shadow-md);
        }

        .decline-button {
            background-color: #4A5568; /* Dark gray for decline */
            color: var(--text-light);
        }

        .decline-button:hover {
            background-color: #2D3748;
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--shadow-md);
        }

        .add-friend {
            padding: clamp(0.8rem, 2vw, 1.2rem);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: auto;
            background-color: rgba(0, 0, 0, 0.1); /* Darker background */
            box-shadow: 0 -5px 10px rgba(0, 0, 0, 0.2); /* Shadow for bottom section */
        }

        .add-friend-form {
            display: flex;
            gap: clamp(0.3rem, 1vw, 0.6rem);
            align-items: center;
        }

        .add-friend-form input {
            flex: 1;
            padding: clamp(0.6rem, 2vw, 0.8rem);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: var(--border-radius-sm);
            font-size: clamp(0.85rem, 2vw, 1rem);
            background-color: rgba(0, 0, 0, 0.2);
            color: var(--text-light);
            min-width: 0;
            transition: all 0.3s ease;
        }
        .add-friend-form input::placeholder {
            color: var(--gray-text);
            opacity: 0.7;
        }

        .add-friend-form input:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 0.2rem rgba(0, 188, 212, 0.2);
            background-color: rgba(0, 0, 0, 0.4);
        }

        .add-friend-form button {
            background: linear-gradient(45deg, var(--secondary-color), var(--primary-color)); /* Gradient button */
            color: var(--text-dark);
            border: none;
            border-radius: var(--border-radius-sm);
            padding: clamp(0.6rem, 2vw, 0.8rem);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            flex-shrink: 0;
            box-shadow: var(--shadow-sm);
        }

        .add-friend-form button:hover {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--shadow-md);
        }
        .add-friend-form button:disabled {
            background: #4A5568;
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
            box-shadow: none;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--dark-bg); /* Main chat area background */
            position: relative;
            height: 100vh;
            border-radius: var(--border-radius-lg);
            overflow: hidden; /* For inner elements like messages */
        }

        .chat-header {
            padding: clamp(0.8rem, 2vw, 1.2rem);
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); /* Gradient header */
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            flex-shrink: 0;
            color: var(--text-dark);
            box-shadow: var(--shadow-sm);
            position: relative; /* For possible animated elements within header */
            z-index: 10;
        }

        .menu-button, .back-button {
            display: none;
            margin-right: clamp(0.6rem, 2vw, 1rem);
            background: none;
            border: none;
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            cursor: pointer;
            color: var(--text-dark);
            padding: 0.3rem;
            transition: transform 0.2s ease, color 0.2s ease;
        }
        .menu-button:hover, .back-button:hover {
            transform: scale(1.1);
            color: rgba(255, 255, 255, 0.8);
        }


        .chat-info {
            flex: 1;
        }

        .chat-name {
            font-weight: 600;
            color: var(--text-dark);
            font-size: clamp(1.1rem, 3vw, 1.4rem);
        }

        .chat-status {
            font-size: clamp(0.75rem, 2vw, 0.9rem);
            color: rgba(255, 255, 255, 0.8);
            margin-top: 0.2rem;
        }

        #activeChat {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: clamp(0.8rem, 2vw, 1.2rem);
            display: flex;
            flex-direction: column;
            gap: clamp(0.6rem, 2vw, 1rem);
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) rgba(255, 255, 255, 0.1);
            background-image: radial-gradient(circle at top left, rgba(106, 27, 154, 0.1) 0%, transparent 30%),
                              radial-gradient(circle at bottom right, rgba(0, 188, 212, 0.1) 0%, transparent 30%); /* Subtle background pattern */
        }
        /* Webkit scrollbar styles */
        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }
        .chat-messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        .chat-messages::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .message {
            max-width: clamp(70%, 80vw, 85%); /* Wider messages */
            padding: clamp(0.6rem, 2vw, 0.9rem) clamp(0.9rem, 3vw, 1.3rem);
            border-radius: var(--border-radius-lg); /* More rounded */
            animation: messageFadeIn 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; /* New message animation */
            position: relative;
            word-break: break-word;
            font-size: clamp(0.9rem, 2.5vw, 1.05rem);
            line-height: 1.4;
            color: var(--text-dark);
            box-shadow: var(--shadow-sm);
        }
        @keyframes messageFadeIn {
            from { opacity: 0; transform: translateY(10px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .message-content {
            margin-bottom: 0.3rem;
        }

        .message-metadata {
            font-size: clamp(0.65rem, 1.5vw, 0.75rem);
            color: var(--gray-text);
            text-align: right;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: clamp(0.2rem, 1vw, 0.4rem);
        }

        .message.outgoing .message-metadata {
            color: rgba(255, 255, 255, 0.7);
        }

        .ephemeral-indicator {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            color: var(--secondary-color); /* Teal clock icon */
        }

        .message.incoming {
            align-self: flex-start;
            background-color: var(--light-bg); /* Lighter dark gray for incoming */
            border-bottom-left-radius: 0.4rem; /* Pointy corner for incoming */
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .message.outgoing {
            align-self: flex-end;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); /* Gradient for outgoing */
            color: var(--text-dark);
            border-bottom-right-radius: 0.4rem; /* Pointy corner for outgoing */
        }

        .chat-input {
            padding: clamp(0.8rem, 2vw, 1.2rem);
            background-color: var(--light-bg); /* Input area background */
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: clamp(0.4rem, 1vw, 0.7rem);
            align-items: center;
            flex-shrink: 0;
            width: 100%;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.3); /* Shadow for input area */
            position: relative;
            z-index: 10;
        }
        
        /* Mobile specific fixed positioning for chat input */
        @media (max-width: 768px) {
            .chat-input {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
            }
        }

        .chat-input input {
            flex: 1;
            padding: clamp(0.6rem, 2vw, 0.9rem) clamp(0.9rem, 3vw, 1.2rem);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: clamp(1.2rem, 3vw, 1.5rem);
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            background-color: rgba(0, 0, 0, 0.2);
            color: var(--text-light);
            transition: all 0.3s ease;
            min-width: 0;
        }
        .chat-input input::placeholder {
            color: var(--gray-text);
            opacity: 0.7;
        }

        .chat-input input:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 0.2rem rgba(0, 188, 212, 0.2);
            background-color: rgba(0, 0, 0, 0.4);
        }

        .chat-input button {
            background: linear-gradient(45deg, var(--secondary-color), var(--primary-color));
            color: var(--text-dark);
            border: none;
            border-radius: 50%;
            width: clamp(2.5rem, 10vw, 3rem); /* Larger button */
            height: clamp(2.5rem, 10vw, 3rem);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            box-shadow: var(--shadow-sm);
        }

        .chat-input button:hover {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            transform: scale(1.1) rotate(5deg); /* Pop and slight rotate */
            box-shadow: var(--shadow-md);
        }

        .chat-input button:disabled {
            background: #4A5568;
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
            box-shadow: none;
        }

        .no-chat-selected {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--gray-text);
            padding: clamp(1.5rem, 5vw, 2.5rem);
            text-align: center;
            background: radial-gradient(circle at center, rgba(0, 188, 212, 0.05) 0%, transparent 60%); /* Subtle radial gradient */
        }

        .no-chat-selected .chat-header {
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); /* Ensure header is themed */
            box-shadow: var(--shadow-sm);
        }
        .no-chat-selected .chat-header .chat-name,
        .no-chat-selected .chat-header .chat-status {
            color: var(--text-dark);
        }

        .no-chat-selected i {
            font-size: clamp(3rem, 10vw, 5rem); /* Larger icon */
            margin-bottom: clamp(0.8rem, 2vw, 1.5rem);
            opacity: 0.6;
            color: var(--secondary-color); /* Teal icon */
            text-shadow: 0 0 10px rgba(0, 188, 212, 0.4);
        }

        .no-chat-selected h3 {
            font-size: clamp(1.5rem, 4vw, 2rem);
            margin-bottom: 0.6rem;
            color: var(--text-dark); /* White text */
            font-weight: 700;
        }

        .no-chat-selected p {
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            line-height: 1.5;
            color: var(--gray-text);
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: clamp(1rem, 5vw, 2rem);
            text-align: center;
            color: var(--gray-text);
            flex: 1;
        }

        .empty-state i {
            font-size: clamp(2rem, 8vw, 4rem);
            margin-bottom: clamp(0.6rem, 2vw, 1rem);
            opacity: 0.6;
            color: var(--primary-color); /* Purple icon */
        }
        .empty-state h3 {
            color: var(--text-light); /* White text */
        }

        .loader {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: clamp(1.5rem, 5vw, 2.5rem);
            flex: 1;
        }

        .spinner {
            border: 0.3rem solid rgba(255, 255, 255, 0.2); /* Thicker, transparent border */
            border-radius: 50%;
            border-top: 0.3rem solid var(--secondary-color); /* Teal spinner */
            width: clamp(2rem, 8vw, 3rem);
            height: clamp(2rem, 8vw, 3rem);
            animation: spin 1s linear infinite;
            box-shadow: 0 0 10px rgba(0, 188, 212, 0.4); /* Subtle glow */
        }

        /* --- Toast Notification Styles --- */
        .toast-container {
            position: fixed;
            bottom: clamp(1rem, 2vw, 1.5rem);
            right: clamp(1rem, 2vw, 1.5rem);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: clamp(0.6rem, 2vw, 0.9rem);
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .toast {
            padding: clamp(0.7rem, 2vw, 1.1rem);
            background-color: var(--light-bg);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            gap: clamp(0.3rem, 1vw, 0.6rem);
            animation: slideInRight 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            max-width: clamp(14rem, 80vw, 20rem); /* Wider toasts */
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
            min-width: clamp(12rem, 60vw, 15rem);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .toast.hiding {
            animation: fadeOut 0.5s ease-out forwards;
        }

        .toast.success {
            border-left: 0.3rem solid var(--success-color);
        }

        .toast.error {
            border-left: 0.3rem solid var(--error-color);
        }

        .toast.info {
            border-left: 0.3rem solid var(--info-color); /* Teal for info */
        }

        .toast-icon {
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            flex-shrink: 0;
        }

        .toast.success .toast-icon {
            color: var(--success-color);
        }

        .toast.error .toast-icon {
            color: var(--error-color);
        }

        .toast.info .toast-icon {
            color: var(--info-color);
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 0.2rem;
            font-size: clamp(0.9rem, 2.5vw, 1.05rem);
        }

        .toast-message {
            font-size: clamp(0.85rem, 2vw, 0.95rem);
            color: var(--gray-text);
            word-break: break-word;
        }

        /* --- Speed Check Container Styles --- */
        .speed-check-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: rgba(0, 0, 0, 0.4); /* Semi-transparent overlay for speed check */
            color: var(--text-light);
            text-align: center;
            padding: clamp(1.5rem, 5vw, 2.5rem);
            width: 100%;
        }

        .speed-check-box {
            background-color: rgba(255, 255, 255, 0.1); /* More transparent background */
            backdrop-filter: blur(8px); /* Stronger blur */
            border-radius: var(--border-radius-lg);
            box-shadow: 0 0.8rem 2rem rgba(0, 0, 0, 0.5); /* Deeper shadow */
            width: clamp(22rem, 90vw, 35rem); /* Larger box */
            padding: clamp(2rem, 6vw, 3rem);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(1.2rem, 4vw, 2rem);
            animation: fadeInScale 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; /* Smoother animation */
            border: 1px solid rgba(255, 255, 255, 0.15); /* Subtle border */
        }

        .speed-check-box h2 {
            font-size: clamp(2rem, 6vw, 3rem);
            margin-bottom: 0.8rem;
            color: var(--text-dark);
            font-weight: 800;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .speed-check-box p {
            font-size: clamp(1rem, 2.8vw, 1.2rem);
            margin-bottom: 1.2rem;
            opacity: 0.9;
            color: var(--gray-text);
        }

        /* Analog Speed Meter */
        .speed-meter-analog {
            position: relative;
            width: clamp(12rem, 35vw, 15rem); /* Larger meter */
            height: clamp(12rem, 35vw, 15rem);
            border-radius: 50%;
            background: linear-gradient(135deg, #333 0%, #111 100%); /* Darker meter background */
            border: clamp(0.6rem, 1.5vw, 0.8rem) solid #222;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.7), 0 0 20px rgba(0, 0, 0, 0.5); /* Enhanced shadow */
            margin-bottom: 1.5rem;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: transform 0.2s ease; /* Add transition for click feedback */
        }
        .speed-meter-analog:active {
            transform: scale(0.98); /* Slight squash on click */
        }

        .speed-meter-analog.disabled {
            opacity: 0.6;
            cursor: default;
            pointer-events: none; /* Disable clicks */
        }

        .speed-meter-fill {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(var(--primary-color) 0%, var(--secondary-color) var(--meter-fill, 0%), transparent var(--meter-fill, 0%));
            transform: rotate(-180deg);
            transform-origin: center;
            transition: --meter-fill 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smoother fill transition */
        }

        .speed-meter-center {
            position: absolute;
            width: 35%; /* Larger center */
            height: 35%;
            background-color: #0F172A; /* Even darker center */
            border-radius: 50%;
            border: 4px solid #4A5568; /* Thicker, slightly lighter border */
            z-index: 2;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.7), 0 0 10px rgba(0, 0, 0, 0.4);
        }

        .speed-meter-needle {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform-origin: bottom center;
            width: 4px; /* Thicker needle */
            height: 48%; /* Slightly longer needle */
            background-color: var(--error-color); /* Red needle */
            border-radius: 50% / 0 0 100% 100%;
            z-index: 3;
            transform: translateX(-50%) rotate(calc(var(--meter-rotation, 0deg) - 180deg));
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smoother needle transition */
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.7); /* Red glow for needle */
        }

        .speed-meter-value-overlay {
            position: absolute;
            font-size: clamp(2rem, 6vw, 3rem);
            font-weight: bold;
            color: var(--text-dark);
            z-index: 4;
            text-shadow: 0 0 10px rgba(0,0,0,0.7), 0 0 15px var(--secondary-color); /* Enhanced text shadow */
        }

        .speed-unit {
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            opacity: 0.8;
            margin-left: 0.3rem;
            font-weight: normal;
        }

        .speed-check-button {
            background: linear-gradient(45deg, var(--secondary-color) 0%, var(--primary-color) 100%); /* Vibrant gradient */
            color: var(--text-dark);
            border: none;
            border-radius: var(--border-radius-md);
            padding: clamp(0.9rem, 3vw, 1.3rem) clamp(1.8rem, 5vw, 2.5rem);
            font-size: clamp(1.1rem, 3vw, 1.4rem);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smoother button transitions */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.05em;
        }

        .speed-check-button:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5), 0 0 20px var(--secondary-color); /* Deeper shadow and glow */
            background: linear-gradient(45deg, var(--primary-color) 0%, var(--secondary-color) 100%); /* Reverse gradient on hover */
        }

        .speed-check-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        /* Ripple effect for button */
        .speed-check-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transition: all 0.75s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
            z-index: 0;
        }

        .speed-check-button:hover::before {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .speed-check-button:disabled {
            background: #4A5568;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
            opacity: 0.7;
        }
        .speed-check-button:disabled::before {
            display: none;
        }

        /* --- Keyframe Animations --- */
        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; display: none; }
        }

        @keyframes slideUp {
            from { transform: translateY(clamp(2rem, 5vw, 3rem)) scale(0.95); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        /* --- Media Queries for Responsiveness --- */
        @media (max-width: 1024px) {
            .app-container {
                grid-template-columns: minmax(0, var(--sidebar-width)) 1fr;
            }
            .auth-box {
                width: clamp(20rem, 95vw, 25rem);
            }
        }

        @media (max-width: 768px) {
            body {
                overflow-y: auto; /* Allow body scroll on mobile for overall page */
            }
            .app-container {
                display: flex;
                flex-direction: column;
                height: auto; /* Allow height to adjust */
                min-height: 100vh;
            }

            .sidebar {
                width: 100%;
                height: 100%;
                position: fixed; /* Use fixed for full overlay */
                top: 0;
                left: 0;
                transform: translateX(-100%);
                box-shadow: var(--shadow-lg); /* Shadow for overlay sidebar */
                z-index: 100; /* Ensure it's on top */
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .menu-button, .back-button {
                display: block;
            }

            .sidebar.active ~ .chat-container #activeChat,
            .sidebar.active ~ .chat-container #noChatSelected {
                display: none;
            }

            .sidebar.active ~ .chat-container::before {
                content: '';
                position: fixed; /* Fixed overlay */
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.6);
                z-index: 90; /* Below sidebar, above chat content */
                animation: fadeIn 0.3s forwards;
            }

            .auth-box {
                width: clamp(16rem, 95vw, 22rem);
                padding: clamp(1rem, 4vw, 2rem);
            }

            /* Increased minimum size for better touch target */
            .chat-input button {
                width: clamp(2.5rem, 8vw, 3rem); 
                height: clamp(2.5rem, 8vw, 3rem);
            }
            /* Increased minimum size for better touch target */
            .friend-avatar {
                width: clamp(2.5rem, 8vw, 3rem);
                height: clamp(2.5rem, 8vw, 3rem);
            }

            .chat-container {
                height: 100vh;
                overflow: hidden;
            }

            #activeChat {
                height: 100%;
            }

            /* Adjust chat-messages padding to account for fixed chat-input height on mobile */
            .chat-messages {
                padding-bottom: calc(clamp(0.8rem, 2vw, 1.2rem) + clamp(2.5rem, 10vw, 3rem) + clamp(0.8rem, 2vw, 1.2rem)); 
            }
        }

        @media (max-width: 480px) {
            :root {
                --base-font-size: clamp(0.8rem, 3.5vw, 0.9rem); /* Slightly increased minimum font size */
                --sidebar-width: 100%;
            }

            .auth-box {
                width: clamp(16rem, 98vw, 20rem); /* Slightly wider on very small screens */
                padding: clamp(1rem, 4vw, 2rem); /* Increased minimum padding */
            }

            .auth-logo h1 {
                font-size: clamp(2rem, 7vw, 2.4rem); /* Increased minimum font size */
            }

            .form-group input {
                padding: clamp(0.6rem, 2.5vw, 0.8rem); /* Increased minimum padding */
            }

            .auth-button {
                padding: clamp(0.7rem, 2.5vw, 1rem) 1rem; /* Increased minimum padding */
                font-size: clamp(0.9rem, 3vw, 1.1rem); /* Increased minimum font size */
            }

            .chat-input input {
                padding: clamp(0.6rem, 2.5vw, 0.9rem) clamp(0.7rem, 3vw, 1rem); /* Increased minimum padding */
            }

            /* Adjust chat-messages padding to prevent content from going under fixed input */
            .chat-messages {
                padding-bottom: calc(clamp(0.8rem, 2vw, 1.2rem) + clamp(2.5rem, 8vw, 3rem) + clamp(0.8rem, 2vw, 1.2rem)); /* Based on increased button size */
            }

            .message {
                max-width: 90%; /* Allow messages to be a bit wider */
                padding: clamp(0.6rem, 2.5vw, 0.9rem) clamp(0.7rem, 3vw, 1rem); /* Increased minimum padding */
            }

            .toast {
                max-width: clamp(12rem, 90vw, 18rem); /* Slightly larger minimum width for toasts */
                min-width: clamp(10rem, 80vw, 14rem);
                bottom: clamp(0.75rem, 3vw, 1rem);
                right: clamp(0.75rem, 3vw, 1rem);
            }
        }
    </style>
</head>
<body>
    <!-- Speed Check Container -->
    <div id="speedCheckContainer" class="speed-check-container">
        <div class="speed-check-box">
            <h2>Internet Speed Test</h2>
            <p id="speedCheckInstruction">Click the dial meter to begin network diagnostics.</p>
            <div class="speed-meter-analog" id="speedMeterAnalog">
                <div class="speed-meter-fill"></div>
                <div class="speed-meter-needle"></div>
                <div class="speed-meter-center"></div>
                <div class="speed-meter-value-overlay" id="speedValue">0<span class="speed-unit">Mbps</span></div>
            </div>
            <button id="speedCheckButton" class="speed-check-button" disabled>
                Start Test
            </button>
        </div>
    </div>

    <!-- Authentication Container (Login/Register) -->
    <div id="authContainer" class="auth-container hidden">
        <div class="auth-box">
            <div class="auth-logo">
                <h1>Ephemeral</h1>
                <p>Self-destructing chats for ultimate privacy</p>
            </div>

            <form id="loginForm" class="auth-form">
                <div class="form-group">
                    <label for="loginEmail">Email</label>
                    <input type="email" id="loginEmail" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" placeholder="Enter your password" required>
                </div>
                <button type="submit" id="loginButton" class="auth-button">
                    <i class="fas fa-sign-in-alt"></i> Login
                </button>
                <div id="loginError" class="error-message hidden"></div>
            </form>

            <form id="registerForm" class="auth-form hidden">
                <div class="form-group">
                    <label for="registerEmail">Email</label>
                    <input type="email" id="registerEmail" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label for="registerPassword">Password</label>
                    <input type="password" id="registerPassword" placeholder="Create a password (min. 6 characters)" required>
                </div>
                <div class="form-group">
                    <label for="confirmPassword">Confirm Password</label>
                    <input type="password" id="confirmPassword" placeholder="Confirm your password" required>
                </div>
                <button type="submit" id="registerButton" class="auth-button">
                    <i class="fas fa-user-plus"></i> Create Account
                </button>
                <div id="registerError" class="error-message hidden"></div>
            </form>

            <div class="auth-alt">
                <p id="loginAlt">Don't have an account? <a id="showRegister">Sign up</a></p>
                <p id="registerAlt" class="hidden">Already have an account? <a id="showLogin">Login</a></p>
            </div>
        </div>
    </div>

    <!-- Username Setup Container -->
    <div id="usernameSetup" class="auth-container hidden">
        <div class="auth-box username-setup">
            <h2>Create Username</h2>
            <p>Choose a unique username that others can use to find you</p>
            <form id="usernameForm" class="auth-form">
                <div class="form-group">
                    <input type="text" id="username" placeholder="Enter username" required>
                </div>
                <button type="submit" id="usernameButton" class="auth-button">
                    <i class="fas fa-check"></i> Set Username
                </button>
                <div id="usernameError" class="error-message hidden"></div>
            </form>
        </div>
    </div>

    <!-- Main Application Container -->
    <div id="appContainer" class="app-container hidden">
        <div id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h2>Ephemeral</h2>
                <div class="user-menu">
                    <button id="userMenuButton" class="user-button">
                        <i class="fas fa-ellipsis-v"></i>
                    </button>
                    <div id="userDropdown" class="dropdown-menu hidden">
                        <ul>
                            <li id="userProfileBtn"><i class="fas fa-user"></i> Profile</li>
                            <li id="logoutBtn"><i class="fas fa-sign-out-alt"></i> Logout</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="tabs">
                <div class="tab active" data-tab="chats">Chats</div>
                <div class="tab" data-tab="requests">Requests</div>
            </div>

            <div id="chatsTab" class="tab-content">
                <div class="search-bar">
                    <i class="fas fa-search"></i>
                    <input type="text" id="searchFriends" placeholder="Search chats">
                </div>

                <div id="friendList" class="friend-list">
                    <div id="emptyFriendList" class="empty-state hidden">
                        <i class="fas fa-comments"></i>
                        <h3>No chats yet</h3>
                        <p>Add friends to start chatting</p>
                    </div>
                    <div id="friendListLoader" class="loader hidden"><div class="spinner"></div></div>
                </div>
            </div>

            <div id="requestsTab" class="tab-content hidden">
                <div class="search-bar">
                    <i class="fas fa-search"></i>
                    <input type="text" id="searchRequests" placeholder="Search requests">
                </div>
                <div id="requestList" class="request-list">
                    <div id="emptyRequestList" class="empty-state hidden">
                        <i class="fas fa-user-friends"></i>
                        <h3>No friend requests</h3>
                        <p>When someone adds you, they'll appear here</p>
                    </div>
                    <div id="requestListLoader" class="loader hidden"><div class="spinner"></div></div>
                </div>
            </div>

            <div class="add-friend">
                <form id="addFriendForm" class="add-friend-form">
                    <input type="text" id="friendUsername" placeholder="Enter username to add">
                    <button type="submit" id="addFriendButton">
                        <i class="fas fa-user-plus"></i>
                    </button>
                </form>
                <div id="addFriendMessage" class="success-message hidden"></div>
                <div id="addFriendError" class="error-message hidden"></div>
            </div>
        </div>

        <div id="chatContainer" class="chat-container">
            <div id="noChatSelected" class="no-chat-selected">
                <div class="chat-header">
                    <button id="menuButton" class="menu-button">
                        <i class="fas fa-bars"></i>
                    </button>
                    <!-- User info in header, even when no chat selected -->
                    <div class="chat-info">
                        <div class="chat-name">Welcome</div>
                        <div class="chat-status">Select a chat to begin</div>
                    </div>
                </div>
                <i class="fas fa-comments"></i>
                <h3>Select a chat to start messaging</h3>
                <p>Or add a new friend to begin a conversation</p>
            </div>

            <div id="activeChat" class="hidden">
                <div class="chat-header">
                    <button id="menuButtonActive" class="menu-button">
                        <i class="fas fa-bars"></i>
                    </button>
                    <button id="backButton" class="back-button">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                    <div class="chat-info">
                        <div class="chat-name" id="chatName"></div>
                        <div class="chat-status">Messages disappear after 24 hours</div>
                    </div>
                </div>

                <div id="chatMessages" class="chat-messages">
                    <div id="chatLoader" class="loader hidden"><div class="spinner"></div></div>
                </div>

                <div class="chat-input">
                    <input type="text" id="messageInput" placeholder="Type a message...">
                    <button type="button" id="sendButton" disabled>
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Global Toast Notification Container -->
    <div id="toastContainer" class="toast-container"></div>

    <script>
        // Firebase Configuration
        // Attempt to use __firebase_config if available (provided by Canvas environment)
        // This is the most robust way to get the correct Firebase configuration.
        const firebaseConfig = {
            apiKey: "AIzaSyBXQAIu0_JwngXpgjuftCsM05kLM6H5OW8", 
            authDomain: "chat-app-e3afc.firebaseapp.com",
            projectId: "chat-app-e3afc",
            storageBucket: "chat-app-e3afc.firebasestorage.app",
            messagingSenderId: "1005413617727",
            appId: "1:1005413617727:web:2f81b1c9139636cd4ee88a"
        };

        if (typeof __firebase_config !== 'undefined' && __firebase_config) {
            try {
                const parsedConfig = JSON.parse(__firebase_config);
                // Merge parsed config with the default to ensure all fields are covered
                firebaseConfig = { ...firebaseConfig, ...parsedConfig };
            } catch (e) {
                console.error("Error parsing __firebase_config:", e);
                // Fallback to the hardcoded placeholder if parsing fails
            }
        }
        console.log("Firebase Config in use:", firebaseConfig); // Log the final config for debugging

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const rtdb = firebase.database(); // Initialize Realtime Database
        
        // Speed Check Variables
        let speedMeterClickCount = 0;
        const REQUIRED_SPEED_METER_CLICKS = 10;
        let speedTestOngoing = false; // To prevent multiple speed tests from running simultaneously
        let speedTestCompleted = false; // Flag to indicate if a speed test has completed

        // Global variable to store the interval ID for lastSeen updates
        let userActivityInterval = null; 

        // Stores unsubscribe functions for real-time listeners for chat messages (for notifications)
        let chatListeners = {}; 

        // Stores unsubscribe functions for real-time listeners for friend user data (for online status)
        let friendStatusListeners = {}; 

        const EPHEMERAL_DURATION_MS = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
        const ONLINE_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes for online status

        // --- DOM Element References ---
        const speedCheckContainer = document.getElementById('speedCheckContainer');
        const speedValueDisplay = document.getElementById('speedValue');
        const speedMeterFill = document.querySelector('.speed-meter-fill');
        const speedMeterNeedle = document.querySelector('.speed-meter-needle');
        const speedMeterAnalog = document.getElementById('speedMeterAnalog');
        const speedCheckButton = document.getElementById('speedCheckButton');
        const speedCheckInstruction = document.getElementById('speedCheckInstruction');

        const authContainer = document.getElementById('authContainer');
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const loginButton = document.getElementById('loginButton');
        const registerButton = document.getElementById('registerButton');
        const loginError = document.getElementById('loginError');
        const registerError = document.getElementById('registerError');
        const showRegister = document.getElementById('showRegister');
        const showLogin = document.getElementById('showLogin');
        const loginAlt = document.getElementById('loginAlt');
        const registerAlt = document.getElementById('registerAlt');
        const usernameSetup = document.getElementById('usernameSetup');
        const usernameForm = document.getElementById('usernameForm');
        const usernameInput = document.getElementById('username');
        const usernameButton = document.getElementById('usernameButton');
        const usernameError = document.getElementById('usernameError');
        const appContainer = document.getElementById('appContainer');
        const sidebar = document.getElementById('sidebar');
        const userMenuButton = document.getElementById('userMenuButton');
        const userDropdown = document.getElementById('userDropdown');
        const userProfileBtn = document.getElementById('userProfileBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const tabs = document.querySelectorAll('.tab');
        const chatsTabContent = document.getElementById('chatsTab');
        const requestsTabContent = document.getElementById('requestsTab');
        const searchFriendsInput = document.getElementById('searchFriends');
        const searchRequestsInput = document.getElementById('searchRequests');
        const friendList = document.getElementById('friendList');
        const requestList = document.getElementById('requestList');
        const emptyFriendList = document.getElementById('emptyFriendList');
        const emptyRequestList = document.getElementById('emptyRequestList');
        const friendListLoader = document.getElementById('friendListLoader');
        const requestListLoader = document.getElementById('requestListLoader');
        const addFriendForm = document.getElementById('addFriendForm');
        const friendUsernameInput = document.getElementById('friendUsername');
        const addFriendButton = document.getElementById('addFriendButton');
        const addFriendMessage = document.getElementById('addFriendMessage');
        const addFriendError = document.getElementById('addFriendError');
        const chatContainer = document.getElementById('chatContainer');
        const noChatSelected = document.getElementById('noChatSelected');
        const activeChat = document.getElementById('activeChat');
        const chatName = document.getElementById('chatName');
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const chatLoader = document.getElementById('chatLoader');
        const menuButton = document.getElementById('menuButton'); // For noChatSelected header
        const menuButtonActive = document.getElementById('menuButtonActive'); // For activeChat header
        const backButton = document.getElementById('backButton');
        const toastContainer = document.getElementById('toastContainer');

        // --- Global State Variables ---
        let currentUser = null; // Firebase Auth user object
        let currentUserData = null; // Firestore user document data (e.g., username)
        let activeChatId = null; // ID of the currently selected chat
        let activeFriendId = null; // ID of the friend in the currently selected chat
        let activeFriendUsername = null; // Username of the friend in the currently selected chat
        let messageListener = null; // Firestore unsubscribe function for active chat messages
        
        // Global objects to store friends and requests data
        let friends = {}; // Stores accepted friends data { [friendId]: { id, username, chatId, hasUnread, lastSeen, isOnline, statusListenerUnsub } }
        let friendRequests = {}; // Stores pending friend requests { [requestId]: { id, fromUserId, fromUsername, status } }

        /**
         * Updates the current user's `lastSeen` timestamp and `isOnline` status in Firestore.
         * This function is called periodically to maintain online status and activity.
         */
        async function updateLastSeenAndOnlineStatus() {
            if (currentUser && currentUserData && currentUser.uid) {
                try {
                    await db.collection('users').doc(currentUser.uid).update({
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                        isOnline: true // Explicitly set online when active in the app
                    });
                } catch (error) {
                    console.error("Error updating lastSeen and isOnline status:", error);
                }
            }
        }

        /**
         * Sets the user's online status in Realtime Database, with an onDisconnect handler.
         * This ensures a reliable "offline" status when the user closes the browser or loses connection.
         * It also sets up listeners to detect if the user's internet connection status changes.
         */
        function setupRealtimePresence() {
            if (!currentUser || !rtdb) return; // Ensure RTDB is initialized

            const userStatusDatabaseRef = rtdb.ref('/presence/' + currentUser.uid);
            
            // Create a reference to the special '.info/connected' path
            const connectedRef = rtdb.ref('.info/connected');

            // Listener for connection status changes
            connectedRef.on('value', async (snapshot) => {
                if (snapshot.val() === true) {
                    // We're connected! Set up onDisconnect and then set online status
                    await userStatusDatabaseRef.onDisconnect().set(false).catch(e => console.error("Error setting onDisconnect:", e)); // Set offline when disconnected
                    await userStatusDatabaseRef.set(true).catch(e => console.error("Error setting RTDB online:", e)); // Set online immediately
                    console.log("Realtime Database: Connected and set user online.");

                    // Also update Firestore if currently connected and online
                    if (currentUser && currentUser.uid) {
                        await db.collection('users').doc(currentUser.uid).update({
                            isOnline: true,
                            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                        }).catch(e => console.error("Error updating Firestore online status:", e));
                    }

                } else {
                    // We've lost connection (or it was never established)
                    console.log("Realtime Database: Disconnected or not connected.");
                    // The onDisconnect will handle setting offline when the connection truly drops.
                    // No explicit action needed here beyond what onDisconnect manages.
                    if (currentUser && currentUser.uid) {
                        // Optionally, update Firestore to offline immediately on client-side disconnect detection
                        db.collection('users').doc(currentUser.uid).update({
                            isOnline: false,
                            lastSeen: firebase.firestore.FieldValue.serverTimestamp() // Update last seen
                        }).catch(e => console.error("Error updating Firestore offline status on disconnect:", e));
                    }
                }
            });

            // Ensure onDisconnect is set up only once and remains (this will be cancelled and re-applied by connectedRef listener)
            // userStatusDatabaseRef.onDisconnect().set(false).catch(error => {
            //     console.error("Error setting up initial Realtime Database onDisconnect:", error);
            // });
        }


        /**
         * Handles user logout.
         * Unsubscribes all Firebase listeners and clears intervals to prevent memory leaks.
         * Also explicitly sets user offline in Realtime Database and Firestore.
         */
        async function handleLogout() {
            try {
                // Clear the lastSeen update interval
                if (userActivityInterval) {
                    clearInterval(userActivityInterval);
                    userActivityInterval = null;
                }

                // Explicitly set user offline in Realtime Database and Firestore
                if (currentUser && currentUser.uid) {
                    const userStatusDatabaseRef = rtdb.ref('/presence/' + currentUser.uid);
                    await userStatusDatabaseRef.onDisconnect().cancel(); // Cancel any pending onDisconnect
                    await userStatusDatabaseRef.set(false); // Set offline immediately

                    await db.collection('users').doc(currentUser.uid).update({
                        isOnline: false,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }

                // Unsubscribe from active chat messages listener
                if (messageListener) {
                    messageListener(); 
                    messageListener = null; // Clear the listener reference
                }

                // Unsubscribe from all chat overview listeners
                for (const chatId in chatListeners) {
                    if (chatListeners[chatId]) {
                        chatListeners[chatId]();
                    }
                }
                chatListeners = {}; // Clear the listeners object

                // Unsubscribe from all friend status listeners
                for (const friendId in friendStatusListeners) {
                    if (friendStatusListeners[friendId]) {
                        // Realtime Database listeners are unsubscribed using .off()
                        rtdb.ref('/presence/' + friendId).off('value', friendStatusListeners[friendId]);
                    }
                }
                friendStatusListeners = {}; // Clear the listeners object

                // Sign out from Firebase Auth
                await auth.signOut();
                showToast('Logged out successfully.', 'info');
            } catch (error) {
                console.error("Logout failed:", error);
                showToast('Logout failed: ' + error.message, 'error');
            }
        }

        // --- UI Utility Functions ---

        /**
         * Shows the specified screen and hides all others.
         * Manages sidebar visibility for mobile.
         * @param {string} screenId - The ID of the screen element to show.
         */
        function showScreen(screenId) {
            document.querySelectorAll('#speedCheckContainer, #authContainer, #usernameSetup, #appContainer').forEach(screen => {
                screen.classList.add('hidden');
            });
            document.getElementById(screenId).classList.remove('hidden');

            // Handle sidebar visibility on mobile
            if (window.innerWidth <= 768 && screenId === 'appContainer') {
                // If appContainer is shown, ensure sidebar is initially active (visible)
                // This means on mobile, the sidebar is the default view for the app.
                sidebar.classList.add('active');
            } else {
                // On desktop or for other screens, ensure sidebar is not active (hidden if it's an overlay)
                // This is important when switching from appContainer to authContainer, for instance.
                sidebar.classList.remove('active');
            }
        }

        /**
         * Toggles the active state of the sidebar (for mobile overlay).
         */
        function toggleSidebar() {
            sidebar.classList.toggle('active');
        }

        /**
         * Toggles the visibility of the user dropdown menu.
         */
        function toggleUserDropdown() {
            userDropdown.classList.toggle('hidden');
        }

        /**
         * Hides the user dropdown menu.
         */
        function hideUserDropdown() {
            userDropdown.classList.add('hidden');
        }

        /**
         * Generates initials from a given name.
         * @param {string} name - The full name or username.
         * @returns {string} The initials (e.g., "JS" for "John Doe", "J" for "John").
         */
        function getInitials(name) {
            if (!name) return '?';
            const parts = name.split(' ');
            if (parts.length > 1) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name[0].toUpperCase();
        }

        /**
         * Formats a Firebase Timestamp object into a human-readable string.
         * For messages, also indicates if a message has expired based on EPHEMERAL_DURATION_MS.
         * For lastSeen, provides relative time.
         * @param {firebase.firestore.Timestamp} timestamp - The Firebase timestamp.
         * @returns {string} Formatted time string.
         */
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = timestamp.toDate();
            const now = new Date();
            const diffMs = now.getTime() - date.getTime();

            const diffSeconds = Math.floor(diffMs / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            const diffDays = Math.floor(diffHours / 24);

            if (diffMinutes < 1) {
                return 'just now';
            } else if (diffMinutes < 60) {
                return `${diffMinutes}m ago`;
            } else if (diffHours < 24) {
                return `${diffHours}h ago`;
            } else if (diffDays < 7) {
                return `${diffDays}d ago`;
            } else {
                const options = { month: 'short', day: 'numeric' };
                if (date.getFullYear() !== now.getFullYear()) {
                    options.year = 'numeric';
                }
                return date.toLocaleDateString(undefined, options);
            }
        }


        /**
         * Filters a list of messages to remove those older than the ephemeral duration.
         * @param {Array<Object>} messages - Array of message objects.
         * @returns {Array<Object>} Filtered array of active messages.
         */
        function filterExpiredMessages(messages) {
            const now = Date.now();
            return messages.filter(msg => {
                if (!msg.timestamp) return false; // Messages without timestamp are considered invalid
                const msgTime = msg.timestamp.toDate().getTime();
                return (now - msgTime) <= EPHEMERAL_DURATION_MS;
            });
        }

        /**
         * Cleans up (deletes) messages from Firestore that have exceeded the ephemeral duration.
         * @param {string} chatId - The ID of the chat to clean up.
         */
        async function cleanUpExpiredMessages(chatId) {
            if (!chatId) return;
            try {
                const messagesRef = db.collection('chats').doc(chatId).collection('messages');
                // Fetch all messages to check for expiration (limit here is for fetching, not for listener)
                const snapshot = await messagesRef.get(); 
                const now = Date.now();

                const deletePromises = [];
                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    // If no timestamp, consider it for deletion or ignore, depending on policy.
                    // Here, we assume messages without timestamps are malformed and should be cleaned.
                    if (!data.timestamp) { 
                        deletePromises.push(doc.ref.delete());
                        return;
                    }
                    const msgTime = data.timestamp.toDate().getTime();
                    if ((now - msgTime) > EPHEMERAL_DURATION_MS) {
                        deletePromises.push(doc.ref.delete());
                    }
                });

                await Promise.all(deletePromises);
            } catch (error) {
                console.error("Error cleaning up expired messages:", error);
                // Not showing a toast for this as it's a background maintenance task.
            }
        }

        /**
         * Renders messages in the chat messages display area.
         * Handles empty states and sorting.
         * @param {Array<Object>} messages - Array of message objects from Firestore.
         */
        function renderMessages(messages) {
            chatMessages.innerHTML = ''; // Clear previous messages
            const filteredMessages = filterExpiredMessages(messages);

            // Handle empty states for chat messages
            if (filteredMessages.length === 0) {
                chatMessages.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-clock"></i>
                        <h3>${messages.length === 0 ? 'No messages yet' : 'All messages have expired'}</h3>
                        <p>${messages.length === 0 ? 'Start a conversation!' : 'Send a new message to continue the conversation.'}</p>
                    </div>
                `;
                return;
            }

            // Sort messages by timestamp in ascending order for correct display flow
            filteredMessages.sort((a, b) => a.timestamp.toDate() - b.timestamp.toDate());

            filteredMessages.forEach(msg => {
                const messageElement = document.createElement('div');
                messageElement.classList.add('message', msg.senderId === currentUser.uid ? 'outgoing' : 'incoming');
                messageElement.id = msg.id; // Assign message ID for easier reference
                const formattedTime = formatTimestamp(msg.timestamp); // Use generic formatTimestamp

                messageElement.innerHTML = `
                    <div class="message-content">${msg.text}</div>
                    <div class="message-metadata">
                        <span class="message-time">${formattedTime}</span>
                        <span class="ephemeral-indicator"><i class="fas fa-clock"></i></span>
                    </div>
                `;
                chatMessages.appendChild(messageElement);
            });

            // Scroll to the bottom to show latest messages
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // --- Authentication Functions ---

        /**
         * Handles user login with email and password.
         * @param {Event} e - The form submission event.
         */
        async function handleLogin(e) {
            e.preventDefault();
            const email = loginEmail.value;
            const password = loginPassword.value;

            loginButton.disabled = true;
            loginError.classList.add('hidden');

            try {
                await auth.signInWithEmailAndPassword(email, password);
            } catch (error) {
                loginError.textContent = error.message;
                loginError.classList.remove('hidden');
                loginButton.disabled = false;
            }
        }

        /**
         * Handles user registration with email and password.
         * Validates password confirmation and length.
         * @param {Event} e - The form submission event.
         */
        async function handleRegister(e) {
            e.preventDefault();
            const email = registerEmail.value;
            const password = registerPassword.value;
            const confirmPassword = document.getElementById('confirmPassword').value;

            if (password !== confirmPassword) {
                registerError.textContent = "Passwords do not match.";
                registerError.classList.remove('hidden');
                return;
            }

            if (password.length < 6) {
                registerError.textContent = "Password must be at least 6 characters.";
                registerError.classList.remove('hidden');
                return;
            }

            registerButton.disabled = true;
            registerError.classList.add('hidden');

            try {
                await auth.createUserWithEmailAndPassword(email, password);
            } catch (error) {
                registerError.textContent = error.message;
                registerError.classList.remove('hidden');
                registerButton.disabled = false;
            }
        }

        /**
         * Switches between login and registration forms.
         * @param {'login'|'register'} formToShow - Which form to display.
         */
        function switchAuthForm(formToShow) {
            if (formToShow === 'register') {
                loginForm.classList.add('hidden');
                loginAlt.classList.add('hidden');
                registerForm.classList.remove('hidden');
                registerAlt.classList.remove('hidden');
                loginError.classList.add('hidden'); // Clear errors when switching
                registerError.classList.add('hidden');
            } else {
                registerForm.classList.add('hidden');
                registerAlt.classList.add('hidden');
                loginForm.classList.remove('hidden');
                loginAlt.classList.remove('hidden');
                loginError.classList.add('hidden'); // Clear errors when switching
                registerError.classList.add('hidden');
            }
        }

        /**
         * Handles setting up the user's username after registration/login.
         * Validates uniqueness and format.
         * @param {Event} e - The form submission event.
         */
        async function handleUsernameSetup(e) {
            e.preventDefault();
            const username = usernameInput.value.trim();

            if (!username) {
                usernameError.textContent = "Username cannot be empty.";
                usernameError.classList.remove('hidden');
                return;
            }

            // Basic alphanumeric validation, min 3 characters
            if (!/^[a-zA-Z0-9]{3,}$/.test(username)) {
                usernameError.textContent = "Username must be alphanumeric and at least 3 characters.";
                usernameError.classList.remove('hidden');
                return;
            }

            usernameButton.disabled = true;
            usernameError.classList.add('hidden');

            try {
                // Check if username already exists
                const usersRef = db.collection('users');
                const snapshot = await usersRef.where('username', '==', username).limit(1).get();

                if (!snapshot.empty) {
                    usernameError.textContent = "Username is already taken.";
                    usernameError.classList.remove('hidden');
                    usernameButton.disabled = false;
                    return;
                }

                // Set user data in Firestore, including initial online status
                await usersRef.doc(currentUser.uid).set({
                    username: username,
                    email: currentUser.email,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastSeen: firebase.firestore.FieldValue.serverTimestamp(), // Initial lastSeen
                    isOnline: true // Set online by default
                }, { merge: true }); // Use merge to avoid overwriting existing data if any

                currentUserData = { username: username, email: currentUser.email, isOnline: true }; // Update global current user data
                
                // Start periodically updating lastSeen for the current user
                userActivityInterval = setInterval(updateLastSeenAndOnlineStatus, 60 * 1000); // Every 60 seconds
                updateLastSeenAndOnlineStatus(); // Initial update immediately

                // Setup Realtime Database presence
                setupRealtimePresence();

                showScreen('appContainer'); // Transition to main app
                showToast('Username set successfully! Welcome to Ephemeral Chat.', 'success');
                setupChatListeners(); // Setup real-time chat listeners
                setupFriendStatusListeners(); // Setup real-time listeners for friends' online status
            } catch (error) {
                console.error("Error setting username:", error);
                usernameError.textContent = "Error setting username: " + error.message;
                usernameError.classList.remove('hidden');
                usernameButton.disabled = false;
            }
        }


        // --- Chat Management Functions ---

        /**
         * Switches between 'Chats' and 'Requests' tabs in the sidebar.
         * @param {'chats'|'requests'} tabName - The name of the tab to activate.
         */
        function switchTab(tabName) {
            tabs.forEach(tab => {
                if (tab.dataset.tab === tabName) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // Show/hide respective tab content and reset search inputs
            if (tabName === 'chats') {
                chatsTabContent.classList.remove('hidden');
                requestsTabContent.classList.add('hidden');
                searchRequestsInput.value = ''; // Clear search on tab switch
                // Re-display requests after clearing search (important if user searched and switched back)
                displayRequests(Object.values(friendRequests).filter(req => req.status === 'pending')); 
            } else {
                chatsTabContent.classList.add('hidden');
                requestsTabContent.classList.remove('hidden');
                searchFriendsInput.value = ''; // Clear search on tab switch
                // Re-display friends after clearing search
                displayFriends(Object.values(friends));
            }
        }

        /**
         * Fetches a user's data from Firestore by their user ID.
         * This is primarily used for getting username and lastSeen (if not online via RTDB).
         * @param {string} userId - The ID of the user.
         * @returns {Promise<Object|null>} User data or null if not found.
         */
        async function fetchUserData(userId) {
            if (!userId) return null;
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                return userDoc.exists ? userDoc.data() : null;
            } catch (error) {
                console.error("Error fetching user data by ID:", userId, error);
                return null;
            }
        }

        /**
         * Fetches a user's data from Firestore by their username.
         * @param {string} username - The username to search for.
         * @returns {Promise<Object|null>} User data (including ID) or null if not found.
         */
        async function fetchUserByUsername(username) {
            if (!username) return null;
            try {
                const snapshot = await db.collection('users').where('username', '==', username).limit(1).get();
                if (!snapshot.empty) {
                    const doc = snapshot.docs[0];
                    return { id: doc.id, ...doc.data() };
                }
                return null;
            } catch (error) {
                console.error("Error fetching user by username:", username, error);
                return null;
            }
        }

        /**
         * Renders the list of accepted friends in the sidebar.
         * @param {Object} friendsToDisplay - An object containing friend data.
         */
        function displayFriends(friendsToDisplay) {
            friendList.innerHTML = ''; // Clear existing list
            const friendArray = Object.values(friendsToDisplay); // Convert object to array for iteration

            if (friendArray.length === 0) {
                emptyFriendList.classList.remove('hidden');
                return;
            }
            emptyFriendList.classList.add('hidden');

            // Sort friends alphabetically by username for consistent display
            friendArray.sort((a, b) => a.username.localeCompare(b.username));

            friendArray.forEach(friend => {
                const friendElement = document.createElement('div');
                friendElement.classList.add('friend-item');
                // Highlight active chat
                if (activeChatId === friend.chatId) {
                    friendElement.classList.add('active');
                }
                // Store data attributes for easy access
                friendElement.dataset.friendId = friend.id;
                friendElement.dataset.chatId = friend.chatId;
                friendElement.dataset.friendUsername = friend.username;

                const avatarInitial = getInitials(friend.username);

                let statusText = '';
                let statusClass = '';

                // Prioritize the isOnline flag from RTDB for immediate status
                if (friend.isOnline) {
                    statusText = 'Online';
                    statusClass = 'online';
                } else {
                    statusText = 'Offline'; 
                    statusClass = 'offline';
                    // Fallback to Firestore's lastSeen if not online via RTDB
                    if (friend.lastSeen) {
                        const formattedLastSeen = formatTimestamp(friend.lastSeen); 
                        if (formattedLastSeen !== '') {
                            statusText = `Last seen ${formattedLastSeen}`;
                        }
                    }
                }

                friendElement.innerHTML = `
                    <div class="friend-avatar">${avatarInitial}</div>
                    <div class="friend-info">
                        <div class="name-and-status">
                            <div class="friend-name">${friend.username}</div>
                            <div class="friend-status">${statusText}</div>
                        </div>
                        <div class="online-indicator ${statusClass}"></div>
                    </div>
                    ${friend.hasUnread ? '<div class="unread-dot"></div>' : ''}
                `;
                friendList.appendChild(friendElement);

                // Add click listener to open chat
                friendElement.addEventListener('click', () => {
                    setActiveChat(friend.chatId, friend.id, friend.username);
                    // On mobile, close sidebar when a chat is selected
                    if (window.innerWidth <= 768) {
                        sidebar.classList.remove('active');
                    }
                });
            });
        }

        /**
         * Renders the list of pending friend requests in the sidebar.
         * @param {Array<Object>} requestsToDisplay - Array of pending friend request objects.
         */
        function displayRequests(requestsToDisplay) {
            requestList.innerHTML = ''; // Clear existing list

            if (requestsToDisplay.length === 0) {
                emptyRequestList.classList.remove('hidden');
                return;
            }
            emptyRequestList.classList.add('hidden');

            // Sort requests by sender username
            requestsToDisplay.sort((a, b) => a.fromUsername.localeCompare(b.fromUsername));

            requestsToDisplay.forEach(request => {
                const requestElement = document.createElement('div');
                requestElement.classList.add('request-item');
                requestElement.dataset.requestId = request.id;

                const avatarInitial = getInitials(request.fromUsername);

                requestElement.innerHTML = `
                    <div class="request-info">
                        <div class="friend-avatar">${avatarInitial}</div>
                        <div class="friend-info">
                            <div class="friend-name">${request.fromUsername}</div>
                            <div class="friend-status">Wants to be friends</div>
                        </div>
                    </div>
                    <div class="request-buttons">
                        <button class="request-button accept-button" onclick="acceptFriendRequest('${request.id}')">
                            <i class="fas fa-check"></i> Accept
                        </button>
                        <button class="request-button decline-button" onclick="declineFriendRequest('${request.id}')">
                            <i class="fas fa-times"></i> Decline
                        </button>
                    </div>
                `;
                requestList.appendChild(requestElement);
            });
        }

        /**
         * Loads accepted friends for the current user from Firestore.
         * Populates the `friends` global object.
         */
        async function loadFriends() {
            if (!currentUser) return;

            friendListLoader.classList.remove('hidden');
            emptyFriendList.classList.add('hidden');

            try {
                const friendshipsRef = db.collection('friendships');
                const snapshot = await friendshipsRef
                    .where('participants', 'array-contains', currentUser.uid)
                    .where('status', '==', 'accepted')
                    .get();

                // Clear previous friend status listeners before re-populating
                for (const friendId in friendStatusListeners) {
                    if (friendStatusListeners[friendId]) {
                        // Realtime Database listeners are unsubscribed using .off()
                        rtdb.ref('/presence/' + friendId).off('value', friendStatusListeners[friendId]);
                    }
                }
                friendStatusListeners = {}; // Reset the object

                friends = {}; // Reset friends object

                for (const doc of snapshot.docs) {
                    const friendship = doc.data();
                    // Determine the friend's ID (the other participant)
                    const friendId = friendship.participants.find(id => id !== currentUser.uid);
                    
                    // Fetch initial friend data (including lastSeen) from Firestore
                    const friendData = await fetchUserData(friendId);

                    if (friendData) {
                        friends[friendId] = {
                            id: friendId,
                            username: friendData.username,
                            chatId: friendship.chatId,
                            hasUnread: false, // Default to false, will be updated by chat listener
                            lastSeen: friendData.lastSeen || null, // Initialize lastSeen from fetched data or null
                            isOnline: false // Default to false, Realtime Database will update this
                        };
                    }
                }

                displayFriends(friends);
                // After loading friends, set up Realtime Database listeners for their presence
                setupFriendStatusListeners();
            } catch (error) {
                console.error("Error loading friends:", error);
                showToast('Failed to load friends.', 'error');
            } finally {
                friendListLoader.classList.add('hidden');
            }
        }

        /**
         * Loads pending friend requests sent to the current user from Firestore.
         * Populates the `friendRequests` global object.
         */
        async function loadFriendRequests() {
            if (!currentUser) return;

            requestListLoader.classList.remove('hidden');
            emptyRequestList.classList.add('hidden');

            try {
                const requestsRef = db.collection('friendRequests');
                const snapshot = await requestsRef
                    .where('toUserId', '==', currentUser.uid)
                    .where('status', '==', 'pending')
                    .get();

                friendRequests = {}; // Reset requests object

                for (const doc of snapshot.docs) {
                    const request = doc.data();
                    const fromUserData = await fetchUserData(request.fromUserId);

                    if (fromUserData) {
                        friendRequests[doc.id] = {
                            id: doc.id,
                            fromUserId: request.fromUserId,
                            fromUsername: fromUserData.username,
                            status: request.status
                        };
                    }
                }

                displayRequests(Object.values(friendRequests).filter(req => req.status === 'pending'));
            } catch (error) {
                console.error("Error loading friend requests:", error);
                showToast('Failed to load friend requests.', 'error');
            } finally {
                requestListLoader.classList.add('hidden');
            }
        }

        /**
         * Handles sending a friend request.
         * Validates input and checks for existing friendships/requests.
         * @param {Event} e - The form submission event.
         */
        async function addFriend(e) {
            e.preventDefault();
            const username = friendUsernameInput.value.trim();

            if (!username) {
                addFriendError.textContent = "Please enter a username.";
                addFriendError.classList.remove('hidden');
                addFriendMessage.classList.add('hidden');
                return;
            }

            if (currentUserData && username === currentUserData.username) {
                addFriendError.textContent = "You cannot add yourself as a friend.";
                addFriendError.classList.remove('hidden');
                addFriendMessage.classList.add('hidden');
                return;
            }

            addFriendButton.disabled = true;
            addFriendError.classList.add('hidden');
            addFriendMessage.classList.add('hidden');

            try {
                const targetUser = await fetchUserByUsername(username);

                if (!targetUser) {
                    addFriendError.textContent = "User not found.";
                    addFriendError.classList.remove('hidden');
                    addFriendButton.disabled = false;
                    return;
                }

                // Check if already friends
                // This check covers both sides of the friendship (currentUser -> targetUser and vice versa)
                const existingFriendshipSnapshot = await db.collection('friendships')
                    .where('participants', 'array-contains', currentUser.uid)
                    .get(); // Get all friendships currentUser is part of

                const isAlreadyFriend = existingFriendshipSnapshot.docs.some(doc => {
                    const participants = doc.data().participants;
                    return participants.includes(targetUser.id) && doc.data().status === 'accepted';
                });

                if (isAlreadyFriend) {
                    addFriendError.textContent = `You are already friends with ${username}.`;
                    addFriendError.classList.remove('hidden');
                    addFriendButton.disabled = false;
                    return;
                }

                // Check if a pending request already exists (from currentUser to targetUser)
                const existingSentRequest = await db.collection('friendRequests')
                    .where('fromUserId', '==', currentUser.uid)
                    .where('toUserId', '==', targetUser.id)
                    .where('status', '==', 'pending')
                    .get();

                if (!existingSentRequest.empty) {
                    addFriendError.textContent = `Friend request already sent to ${username}.`;
                    addFriendError.classList.remove('hidden');
                    addFriendButton.disabled = false;
                    return;
                }

                // Check if a pending request already exists (from targetUser to currentUser)
                const existingReceivedRequest = await db.collection('friendRequests')
                    .where('fromUserId', '==', targetUser.id)
                    .where('toUserId', '==', currentUser.uid)
                    .where('status', '==', 'pending')
                    .get();

                if (!existingReceivedRequest.empty) {
                    addFriendError.textContent = `${username} has already sent you a friend request. Check the 'Requests' tab.`;
                    addFriendError.classList.remove('hidden');
                    addFriendButton.disabled = false;
                    return;
                }

                // Send friend request
                await db.collection('friendRequests').add({
                    fromUserId: currentUser.uid,
                    toUserId: targetUser.id,
                    status: 'pending',
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });

                addFriendMessage.textContent = `Friend request sent to ${username}!`;
                addFriendMessage.classList.remove('hidden');
                friendUsernameInput.value = ''; // Clear input
                showToast('Friend request sent!', 'success');

            } catch (error) {
                console.error("Error adding friend:", error);
                addFriendError.textContent = "Failed to send friend request. " + error.message;
                addFriendError.classList.remove('hidden');
            } finally {
                addFriendButton.disabled = false;
            }
        }

        /**
         * Accepts a friend request. Creates a chat and friendship, then updates request status.
         * @param {string} requestId - The ID of the friend request to accept.
         */
        async function acceptFriendRequest(requestId) {
            try {
                const request = friendRequests[requestId];
                if (!request) {
                    showToast('Friend request not found.', 'error');
                    return;
                }

                // Create a new chat document
                const chatRef = await db.collection('chats').add({
                    participants: [currentUser.uid, request.fromUserId],
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Create friendship records for both users
                // Note: In a real app, you might only need one friendship record or mirrored ones for simplicity.
                // Here, we're creating one that includes both participants and links to the chat.
                await db.collection('friendships').add({
                    participants: [currentUser.uid, request.fromUserId],
                    chatId: chatRef.id,
                    status: 'accepted',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Update the friend request status to 'accepted'
                await db.collection('friendRequests').doc(requestId).update({
                    status: 'accepted'
                });

                showToast(`You are now friends with ${request.fromUsername}!`, 'success');
                
                // Reload friends and requests to update UI
                await loadFriends(); // loadFriends will now also setup RTDB listeners
                await loadFriendRequests();
                setupChatListeners(); // Re-setup listeners to include the new chat

            } catch (error) {
                console.error("Error accepting friend request:", error);
                showToast('Failed to accept friend request.', 'error');
            }
        }

        /**
         * Declines a friend request by updating its status.
         * @param {string} requestId - The ID of the friend request to decline.
         */
        async function declineFriendRequest(requestId) {
            try {
                await db.collection('friendRequests').doc(requestId).update({
                    status: 'declined'
                });

                showToast('Friend request declined.', 'info');
                await loadFriendRequests(); // Reload requests to update UI

            } catch (error) {
                console.error("Error declining friend request:", error);
                showToast('Failed to decline friend request.', 'error');
            }
        }

        /**
         * Sets the active chat, updates the UI, and loads messages.
         * @param {string} chatId - The ID of the chat document.
         * @param {string} friendId - The ID of the friend in this chat.
         * @param {string} friendUsername - The username of the friend.
         */
        function setActiveChat(chatId, friendId, friendUsername) {
            activeChatId = chatId;
            activeFriendId = friendId;
            activeFriendUsername = friendUsername;

            // Update UI to highlight the active chat in the sidebar
            document.querySelectorAll('.friend-item').forEach(item => {
                item.classList.remove('active');
            });
            const activeItem = document.querySelector(`[data-chat-id="${chatId}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }

            noChatSelected.classList.add('hidden'); // Hide "no chat selected" message
            activeChat.classList.remove('hidden'); // Show active chat interface
            chatName.textContent = friendUsername; // Set chat header name

            // Clear unread indicator for the selected chat
            if (friends[friendId]) {
                friends[friendId].hasUnread = false;
                displayFriends(friends); // Re-render sidebar to remove unread dot
            }

            loadMessages(chatId); // Load messages for the selected chat
        }

        /**
         * Clears the active chat, returning to the "no chat selected" state.
         * Unsubscribes the active chat message listener.
         */
        function clearActiveChat() {
            activeChatId = null;
            activeFriendId = null;
            activeFriendUsername = null;

            // Unsubscribe from the current active chat messages listener to stop real-time updates
            if (messageListener) {
                messageListener(); 
                messageListener = null; // Clear the listener reference
            }

            activeChat.classList.add('hidden'); // Hide active chat interface
            noChatSelected.classList.remove('hidden'); // Show "no chat selected" message

            // Remove active highlight from all friend items
            document.querySelectorAll('.friend-item').forEach(item => {
                item.classList.remove('active');
            });
            // Ensure sidebar is active when going back to friend list on mobile
            if (window.innerWidth <= 768) {
                sidebar.classList.add('active');
            }
        }

        /**
         * Loads messages for the given chat ID in real-time.
         * Sets up an `onSnapshot` listener and handles initial cleanup of expired messages.
         * @param {string} chatId - The ID of the chat document.
         */
        async function loadMessages(chatId) {
            if (!chatId) return;

            chatLoader.classList.remove('hidden'); // Show loader

            try {
                // Clean up expired messages initially and periodically (Firestore Rules or Cloud Functions could automate this)
                // For now, doing it on load to ensure messages aren't displayed if expired.
                await cleanUpExpiredMessages(chatId);

                // Unsubscribe previous listener if any, to avoid multiple listeners on the same chat
                if (messageListener) {
                    messageListener(); 
                }

                const messagesRef = db.collection('chats').doc(chatId).collection('messages');
                // Set up real-time listener for current chat messages, ordered by timestamp
                messageListener = messagesRef
                    .orderBy('timestamp', 'asc') // Order ascending for chat history display
                    .limit(50) // Limit to last 50 messages for performance
                    .onSnapshot(snapshot => {
                        const messages = snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));

                        renderMessages(messages);
                        chatLoader.classList.add('hidden'); // Hide loader once messages are rendered
                    }, (error) => {
                        console.error("Error listening to messages:", error);
                        showToast('Failed to load messages in real-time.', 'error');
                        chatLoader.classList.add('hidden');
                    });

            } catch (error) {
                console.error("Error preparing message load:", error);
                showToast('Failed to load messages.', 'error');
                chatLoader.classList.add('hidden');
            }
        }

        /**
         * Sends a message to the active chat.
         */
        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || !activeChatId) return; // Don't send empty messages or if no chat is active

            try {
                await db.collection('chats').doc(activeChatId).collection('messages').add({
                    text: text,
                    senderId: currentUser.uid,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp() // Server timestamp for consistency
                });

                messageInput.value = ''; // Clear input field
                sendButton.disabled = true; // Disable send button after sending

            } catch (error) {
                console.error("Error sending message:", error);
                showToast('Failed to send message.', 'error');
            }
        }

        /**
         * Displays a temporary toast notification.
         * @param {string} message - The message to display.
         * @param {'info'|'success'|'error'} type - The type of toast (affects styling and icon).
         */
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.classList.add('toast', type);

            const iconMap = {
                success: 'fas fa-check-circle',
                error: 'fas fa-exclamation-circle',
                info: 'fas fa-info-circle'
            };

            toast.innerHTML = `
                <div class="toast-icon">
                    <i class="${iconMap[type]}"></i>
                </div>
                <div class="toast-content">
                    <div class="toast-message">${message}</div>
                </div>
            `;

            toastContainer.appendChild(toast);

            // Automatically hide toast after 3 seconds
            setTimeout(() => {
                toast.classList.add('hiding'); // Add hiding class for fade out animation
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast); // Remove from DOM after animation
                    }
                }, 500); // Match fadeOut animation duration
            }, 3000);
        }

        /**
         * Sets up real-time listeners for all accepted chats to detect new incoming messages
         * and update unread indicators.
         */
        async function setupChatListeners() {
            if (!currentUser) return;

            // Clear existing chat listeners to prevent duplicates and stale listeners
            for (const chatId in chatListeners) {
                if (chatListeners[chatId]) {
                    chatListeners[chatId](); // Unsubscribe
                }
            }
            chatListeners = {}; // Reset the object

            try {
                // Get all accepted chats for the current user
                const friendshipsSnapshot = await db.collection('friendships')
                    .where('participants', 'array-contains', currentUser.uid)
                    .where('status', '==', 'accepted')
                    .get();

                friendshipsSnapshot.docs.forEach(doc => {
                    const friendship = doc.data();
                    const chatId = friendship.chatId;

                    // Attach a listener to each chat's messages subcollection to get the latest message
                    const listener = db.collection('chats').doc(chatId).collection('messages')
                        .orderBy('timestamp', 'desc')
                        .limit(1) // Only interested in the latest message
                        .onSnapshot(snapshot => {
                            // Check if a new message exists and it's not from the current user
                            if (!snapshot.empty) {
                                const latestMessage = snapshot.docs[0].data();
                                
                                // Ensure the message is actually new and not from self, and not expired
                                if (latestMessage.senderId !== currentUser.uid && (Date.now() - latestMessage.timestamp.toDate().getTime()) <= EPHEMERAL_DURATION_MS) {
                                    
                                    // Update unread status in sidebar if this is not the currently active chat
                                    if (activeChatId !== chatId) {
                                        const friendIdInChat = friendship.participants.find(id => id !== currentUser.uid);
                                        if (friends[friendIdInChat]) {
                                            friends[friendIdInChat].hasUnread = true;
                                            displayFriends(friends); // Re-render sidebar to show unread dot
                                        }
                                    }
                                }
                            }
                        }, (error) => {
                            console.error(`Error listening to chat ${chatId} for updates:`, error);
                        });
                    
                    chatListeners[chatId] = listener; // Store listener to unsubscribe later
                });
            } catch (error) {
                console.error("Error setting up chat listeners:", error);
            }
        }

        /**
         * Sets up real-time listeners for each friend's online status using Realtime Database.
         * This provides immediate online/offline updates.
         */
        async function setupFriendStatusListeners() {
            if (!currentUser || !rtdb) return; // Ensure RTDB is initialized

            // Clear existing listeners
            for (const friendId in friendStatusListeners) {
                if (friendStatusListeners[friendId]) {
                    // Realtime Database listeners are unsubscribed using .off()
                    rtdb.ref('/presence/' + friendId).off('value', friendStatusListeners[friendId]);
                }
            }
            friendStatusListeners = {}; // Reset the object

            // Iterate through current friends and set up RTDB listeners
            for (const friendId in friends) {
                const friendPresenceRef = rtdb.ref('/presence/' + friendId);
                
                // Define the listener callback function
                const listenerCallback = (snapshot) => {
                    if (friends[friendId]) {
                        const isOnline = snapshot.val() === true; // Value will be true or false
                        friends[friendId].isOnline = isOnline;

                        // Only update lastSeen from Firestore if the user is currently NOT online via RTDB.
                        // This prevents Firestore's lastSeen from being inaccurate for truly online users.
                        if (!isOnline) {
                            // If friend is offline, fetch their lastSeen from Firestore
                            // This ensures we have the latest lastSeen timestamp for offline display
                            db.collection('users').doc(friendId).get().then(doc => {
                                if (doc.exists && doc.data().lastSeen) {
                                    friends[friendId].lastSeen = doc.data().lastSeen;
                                } else {
                                    friends[friendId].lastSeen = null; // Clear if no lastSeen
                                }
                                displayFriends(friends); // Re-render to show updated status
                            }).catch(error => {
                                console.error(`Error fetching lastSeen for friend ${friendId}:`, error);
                                friends[friendId].lastSeen = null; // Ensure consistency on error
                                displayFriends(friends); // Re-render even on error to update state
                            });
                        } else {
                            // For online users, set lastSeen to current time (from Realtime Database's server timestamp equivalent)
                            // This ensures 'just now' is accurate for online users.
                            // We don't need to explicitly fetch Firestore's lastSeen for online users.
                            friends[friendId].lastSeen = firebase.firestore.Timestamp.now(); // Use Firestore Timestamp.now() for consistency
                            displayFriends(friends); // Re-render to show updated status
                        }
                    }
                };

                // Attach the listener and store the callback function itself for .off()
                friendPresenceRef.on('value', listenerCallback);
                friendStatusListeners[friendId] = listenerCallback; // Store the function reference
            }
        }


        // --- Speed Check Functions ---

        /**
         * Initializes the state of the speed test screen.
         * Resets click count, test status, and UI elements.
         */
        function initializeSpeedTestScreen() {
            speedMeterClickCount = 0; // Reset click count for network check
            speedTestOngoing = false; // Reset speed test animation flag
            speedTestCompleted = false; // Reset completed flag
            speedCheckButton.disabled = true; // Button disabled by default until speed test runs
            speedCheckButton.textContent = 'Start Test';
            speedCheckInstruction.textContent = 'Click the dial meter to begin network diagnostics.'; // Initial instruction
            speedMeterAnalog.classList.remove('disabled'); // Ensure meter is clickable
            speedMeterAnalog.style.cursor = 'pointer'; // Show pointer cursor for interaction
            // Ensure the click listener for advancing to next screen is active
            speedMeterAnalog.removeEventListener('click', handleSpeedMeterClick); // Remove existing to prevent duplicates
            speedMeterAnalog.addEventListener('click', handleSpeedMeterClick); // Re-add listener for the initial gatekeeping clicks
            speedValueDisplay.innerHTML = `0<span class="speed-unit">Mbps</span>`;
            speedMeterFill.style.setProperty('--meter-fill', `0%`);
            speedMeterNeedle.style.setProperty('--meter-rotation', `0deg`);
        }

        /**
         * Handles clicks on the speed meter dial.
         * Each click contributes to a count. After `REQUIRED_SPEED_METER_CLICKS`,
         * the user is advanced to the appropriate screen (auth or app).
         */
        function handleSpeedMeterClick() {
            if (speedTestOngoing) { 
                // If a speed test simulation is currently running, ignore clicks on the meter
                return;
            }

            speedMeterClickCount++;
            
            // Update instruction for engagement, but no explicit countdown
            speedCheckInstruction.textContent = `Keep clicking to perform network diagnostics.`;

            if (speedMeterClickCount >= REQUIRED_SPEED_METER_CLICKS) {
                // User has performed enough clicks, remove the click listener for the gatekeeping
                speedMeterAnalog.removeEventListener('click', handleSpeedMeterClick);
                
                // Determine destination after successful clicks
                if (currentUser) {
                    // User is authenticated
                    if (currentUserData && currentUserData.username) { // Check if username is already set
                        showScreen('appContainer');
                        showToast('Network check passed. Welcome to Ephemeral Chat!', 'success');
                    } else {
                        showScreen('usernameSetup'); // Authenticated but no username set
                        showToast('Network check passed. Please set your username to continue.', 'info');
                    }
                } else {
                    // User is not authenticated
                    showScreen('authContainer');
                    showToast('Network check passed. Please login or register to continue.', 'info');
                }
                // Reset click count only AFTER moving to the next screen, to avoid interference if user clicks back.
                // This reset happens automatically when showScreen leads to a screen that calls initializeSpeedTestScreen.
            } else {
                // If not enough clicks, enable the "Start Test" button for the actual speed test simulation
                // This ensures the button is available once the user starts interacting with the meter.
                speedCheckButton.disabled = false;
            }
        }

        /**
         * Simulates an internet speed test with a dynamic animation of the dial meter.
         * Updates speed value, meter fill, and needle rotation.
         */
        function simulateSpeedTest() {
            if (speedTestOngoing) return; // Prevent multiple simultaneous tests

            speedTestOngoing = true; // Set flag to true

            // Immediately disable interactions when test starts
            speedCheckButton.disabled = true;
            speedMeterAnalog.classList.add('disabled'); // Make meter visually disabled
            speedMeterAnalog.style.cursor = 'default';
            speedMeterAnalog.removeEventListener('click', handleSpeedMeterClick); // Temporarily remove click handler for the meter during test

            speedCheckButton.textContent = 'Testing...';
            speedCheckInstruction.textContent = 'Measuring your internet speed... Please wait.';

            let progress = 0;
            const maxSpeed = Math.random() * 80 + 20; // Random speed between 20-100 Mbps for variety
            let phase = 0; // 0: initial climb, 1: stable, 2: final drop/stabilize

            const interval = setInterval(() => {
                if (phase === 0) { // Initial rapid climb phase
                    progress += Math.random() * 5 + 2; // Increase progress faster
                    if (progress >= 60) phase = 1; // Transition to stable phase
                } else if (phase === 1) { // Stable, slower increase phase
                    progress += Math.random() * 2; 
                    if (progress >= 95) phase = 2; // Transition to final phase
                } else { // Final push to 100%
                    progress += Math.random() * 1 + 0.5;
                }
                
                if (progress > 100) progress = 100; // Cap at 100%

                const currentSpeed = (progress / 100) * maxSpeed;
                const rotation = (progress / 100) * 180; // Map 0-100% to 0-180 degrees for half circle

                speedValueDisplay.innerHTML = `${currentSpeed.toFixed(1)}<span class="speed-unit">Mbps</span>`;
                speedMeterFill.style.setProperty('--meter-fill', `${progress}%`);
                speedMeterNeedle.style.setProperty('--meter-rotation', `${rotation}deg`);

                if (progress >= 100) {
                    clearInterval(interval); // Stop the animation
                    speedTestOngoing = false; // Test animation finished
                    speedTestCompleted = true; // Mark test as completed

                    speedCheckButton.disabled = false; // Re-enable button
                    speedCheckButton.textContent = 'Run Test Again'; // Change button text

                    // Re-enable meter for chat access clicks (its primary function after initial gate)
                    speedMeterAnalog.classList.remove('disabled');
                    speedMeterAnalog.style.cursor = 'pointer';
                    speedMeterAnalog.addEventListener('click', handleSpeedMeterClick); // Re-add listener for chat entry clicks

                    speedCheckInstruction.textContent = `Network analysis complete. Click the dial meter to begin network diagnostics.`;
                    showToast(`Speed Test complete: ${currentSpeed.toFixed(1)} Mbps`, 'info');
                }
            }, 100); // Update every 100ms for smooth animation
        }

        // --- Event Listeners ---

        // Initial setup for speed meter clicks. This listener is persistent unless temporarily removed by specific actions.
        speedMeterAnalog.addEventListener('click', handleSpeedMeterClick);
        speedCheckButton.addEventListener('click', simulateSpeedTest); 

        // Authentication form listeners
        loginForm.addEventListener('submit', handleLogin);
        registerForm.addEventListener('submit', handleRegister);
        showRegister.addEventListener('click', () => switchAuthForm('register'));
        showLogin.addEventListener('click', () => switchAuthForm('login'));
        usernameForm.addEventListener('submit', handleUsernameSetup);

        // App-specific listeners
        logoutBtn.addEventListener('click', handleLogout);
        userMenuButton.addEventListener('click', toggleUserDropdown);
        // Menu button to open sidebar on small screens (from "no chat selected" view)
        menuButton.addEventListener('click', toggleSidebar);
        // Menu button to open sidebar on small screens (from "active chat" view)
        menuButtonActive.addEventListener('click', toggleSidebar);
        // Back button in chat header on small screens
        backButton.addEventListener('click', clearActiveChat);
        addFriendForm.addEventListener('submit', addFriend);

        // Tab switching listeners
        tabs.forEach(tab => {
            tab.addEventListener('click', () => switchTab(tab.dataset.tab));
        });

        // Message input and send button listeners
        messageInput.addEventListener('input', () => {
            sendButton.disabled = !messageInput.value.trim(); // Disable if input is empty
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !sendButton.disabled) {
                sendMessage();
            }
        });

        sendButton.addEventListener('click', sendMessage);

        // Search functionality for friends and requests
        searchFriendsInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            const filteredFriends = Object.values(friends).filter(friend =>
                friend.username.toLowerCase().includes(query)
            );
            displayFriends(filteredFriends);
        });

        searchRequestsInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            // Filter requests based on current status (pending) and search query
            const filteredRequests = Object.values(friendRequests).filter(request =>
                request.fromUsername.toLowerCase().includes(query) && request.status === 'pending'
            );
            displayRequests(filteredRequests);
        });

        // Close user dropdown when clicking outside
        document.addEventListener('click', (e) => {
            // Check if click is outside both the button and the dropdown
            if (!userMenuButton.contains(e.target) && !userDropdown.contains(e.target)) {
                hideUserDropdown();
            }
        });

        // --- Firebase Authentication State Observer ---
        // This runs whenever the user's authentication state changes (login, logout, initial load)
        auth.onAuthStateChanged(async (user) => {
            currentUser = user; // Update the global currentUser object

            // Clear any existing activity interval to prevent multiple intervals
            if (userActivityInterval) {
                clearInterval(userActivityInterval);
                userActivityInterval = null;
            }

            // Always show speedCheckContainer first when auth state changes or on initial load
            showScreen('speedCheckContainer');
            initializeSpeedTestScreen(); // Reset speed test state every time this screen is shown

            if (user) { // User is logged in
                try {
                    // Fetch user's custom data (like username and isOnline) from Firestore
                    const userDoc = await db.collection('users').doc(user.uid).get();
                    if (userDoc.exists) {
                        currentUserData = userDoc.data();
                        
                        // Start periodically updating lastSeen and isOnline for the current user
                        userActivityInterval = setInterval(updateLastSeenAndOnlineStatus, 60 * 1000); // Every 60 seconds
                        updateLastSeenAndOnlineStatus(); // Initial update immediately

                        // Setup Realtime Database presence
                        setupRealtimePresence();

                        // Pre-load necessary data in the background. The actual UI will be shown
                        // only after the network check is completed (via handleSpeedMeterClick).
                        await loadFriends(); 
                        await loadFriendRequests();
                        setupChatListeners(); // Setup real-time listeners for all chats (for new messages)
                        // setupFriendStatusListeners() is now called within loadFriends()

                    } else {
                        // User is authenticated but hasn't set up a username yet.
                        currentUserData = null; 
                        // Show toast, but user will only see it after completing speed check.
                        showToast('Please set your username after network check.', 'info');
                    }
                } catch (error) {
                    console.error("Error fetching user data:", error);
                    showToast('Error loading user data.', 'error');
                }
            } else {
                // User is not logged in. Ensure currentUserData is null.
                currentUserData = null;
                // Speed check screen is already set up by initializeSpeedTestScreen.
            }
        });

        // Add a listener for browser window/tab closing or navigation (best effort)
        window.addEventListener('beforeunload', async () => {
            if (currentUser && currentUser.uid) {
                // This will be handled by Realtime Database's onDisconnect,
                // but we also update Firestore for consistency and explicit state.
                try {
                    await db.collection('users').doc(currentUser.uid).update({
                        isOnline: false,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    // Realtime Database onDisconnect is already setup and more reliable for immediate disconnects.
                } catch (error) {
                    console.warn("Could not explicitly update Firestore status on beforeunload:", error);
                }
            }
        });

        // Expose functions to the global window object so they can be called from inline HTML (onclick)
        window.acceptFriendRequest = acceptFriendRequest;
        window.declineFriendRequest = declineFriendRequest;

        // Note: document.addEventListener('DOMContentLoaded', initializeSpeedTestScreen) is no longer needed
        // because auth.onAuthStateChanged already handles the initial screen setup reliably.
    </script>
</body>
</html>
